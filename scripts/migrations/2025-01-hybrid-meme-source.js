#!/usr/bin/env node

/**
 * Ë≥áÊñôÈÅ∑ÁßªËÖ≥Êú¨ÔºöÂ∞éÂÖ•‰∏âÂ±§‰æÜÊ∫êÁµêÊßãÔºàSource/Scene/MemeÔºâ
 * 
 * Âü∑Ë°åÊñπÂºèÔºö
 * node scripts/migrations/2025-01-hybrid-meme-source.js
 * 
 * ÂäüËÉΩÔºö
 * 1. Âú® memes ÈõÜÂêàÂä†ÂÖ•Êñ∞Ê¨Ñ‰ΩçÔºösource_id, scene_id, variant_of, lineage, body
 * 2. Ë®àÁÆó‰∏¶Êõ¥Êñ∞ÊâÄÊúâËø∑Âõ†ÁöÑ lineageÔºàÁ≥ªË≠úÔºâ
 * 3. Êõ¥Êñ∞‰æÜÊ∫êÂíåÁâáÊÆµÁöÑÁµ±Ë®àÊï∏Êìö
 * 4. Âª∫Á´ãÂøÖË¶ÅÁöÑÁ¥¢Âºï
 */

import mongoose from 'mongoose'
import dotenv from 'dotenv'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// ËºâÂÖ•Áí∞Â¢ÉËÆäÊï∏
dotenv.config({ path: path.join(__dirname, '../../.env') })

// ÂåØÂÖ•Ê®°Âûã
import Meme from '../../models/Meme.js'
import Source from '../../models/Source.js'
import Scene from '../../models/Scene.js'

// ÈÄ£Êé•Ë≥áÊñôÂ∫´
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/memedam', {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    })
    console.log('‚úÖ Ë≥áÊñôÂ∫´ÈÄ£Êé•ÊàêÂäü')
  } catch (error) {
    console.error('‚ùå Ë≥áÊñôÂ∫´ÈÄ£Êé•Â§±Êïó:', error)
    process.exit(1)
  }
}

// ÈÄ≤Â∫¶ËøΩËπ§Âô®
class ProgressTracker {
  constructor(total, taskName) {
    this.total = total
    this.current = 0
    this.taskName = taskName
    this.startTime = Date.now()
  }

  update(increment = 1) {
    this.current += increment
    const percentage = ((this.current / this.total) * 100).toFixed(2)
    const elapsed = (Date.now() - this.startTime) / 1000
    const rate = this.current / elapsed
    const remaining = (this.total - this.current) / rate
    
    process.stdout.write(
      `\r${this.taskName}: ${this.current}/${this.total} (${percentage}%) ` +
      `- Â∑≤Áî®ÊôÇ: ${elapsed.toFixed(1)}s, È†êË®àÂâ©È§ò: ${remaining.toFixed(1)}s`
    )
  }

  complete() {
    const elapsed = (Date.now() - this.startTime) / 1000
    console.log(`\n‚úÖ ${this.taskName} ÂÆåÊàêÔºÅÁ∏ΩÁî®ÊôÇ: ${elapsed.toFixed(1)}s`)
  }
}

// Ê≠•È©ü 1ÔºöÁÇ∫ memes ÈõÜÂêàÊ∑ªÂä†Êñ∞Ê¨Ñ‰Ωç
const addNewFieldsToMemes = async () => {
  console.log('\nüìù Ê≠•È©ü 1ÔºöÁÇ∫ memes ÈõÜÂêàÊ∑ªÂä†Êñ∞Ê¨Ñ‰Ωç...')
  
  try {
    // Ê™¢Êü•ÊòØÂê¶Â∑≤ÊúâÈÄô‰∫õÊ¨Ñ‰Ωç
    const sampleMeme = await Meme.findOne().lean()
    if (sampleMeme && 'source_id' in sampleMeme) {
      console.log('‚ö†Ô∏è  Ê¨Ñ‰ΩçÂ∑≤Â≠òÂú®ÔºåË∑≥ÈÅéÊ≠§Ê≠•È©ü')
      return
    }

    // ‰ΩøÁî® bulkWrite ÊâπÊ¨°Êõ¥Êñ∞
    const bulkOps = []
    const memes = await Meme.find({}).select('_id').lean()
    const tracker = new ProgressTracker(memes.length, 'Ê∑ªÂä†Êñ∞Ê¨Ñ‰Ωç')

    for (const meme of memes) {
      bulkOps.push({
        updateOne: {
          filter: { _id: meme._id },
          update: {
            $setOnInsert: {
              source_id: null,
              scene_id: null,
              variant_of: null,
              lineage: {
                root: meme._id,
                depth: 0,
              },
              body: '',
            },
          },
          upsert: false,
        },
      })

      // ÊØè 1000 Á≠ÜÂü∑Ë°å‰∏ÄÊ¨°ÊâπÊ¨°Êõ¥Êñ∞
      if (bulkOps.length >= 1000) {
        await Meme.bulkWrite(bulkOps, { ordered: false })
        tracker.update(bulkOps.length)
        bulkOps.length = 0
      }
    }

    // ËôïÁêÜÂâ©È§òÁöÑÊõ¥Êñ∞
    if (bulkOps.length > 0) {
      await Meme.bulkWrite(bulkOps, { ordered: false })
      tracker.update(bulkOps.length)
    }

    tracker.complete()
  } catch (error) {
    console.error('‚ùå Ê∑ªÂä†Êñ∞Ê¨Ñ‰ΩçÂ§±Êïó:', error)
    throw error
  }
}

// Ê≠•È©ü 2ÔºöË®àÁÆó‰∏¶Êõ¥Êñ∞ lineageÔºàÁ≥ªË≠úÔºâ
const calculateLineage = async () => {
  console.log('\nüå≥ Ê≠•È©ü 2ÔºöË®àÁÆó‰∏¶Êõ¥Êñ∞ lineageÔºàÁ≥ªË≠úÔºâ...')
  
  try {
    // ÊâæÂá∫ÊâÄÊúâÊúâ variant_of ÁöÑËø∑Âõ†
    const variantMemes = await Meme.find({ 
      variant_of: { $ne: null } 
    }).select('_id variant_of').lean()

    if (variantMemes.length === 0) {
      console.log('‚ö†Ô∏è  Ê≤íÊúâËÆäÈ´îËø∑Âõ†ÔºåË∑≥ÈÅéÊ≠§Ê≠•È©ü')
      return
    }

    const tracker = new ProgressTracker(variantMemes.length, 'Ë®àÁÆóÁ≥ªË≠ú')
    const bulkOps = []

    for (const meme of variantMemes) {
      let root = meme.variant_of
      let depth = 1
      const seen = new Set([String(meme._id)])

      // Âêë‰∏äËøΩÊ∫ØÊâæÂà∞Ê†πÊ∫ê
      while (root) {
        if (seen.has(String(root))) {
          console.warn(`\n‚ö†Ô∏è  Ê™¢Ê∏¨Âà∞Âæ™Áí∞ÂºïÁî®: ${meme._id}`)
          break
        }
        seen.add(String(root))

        const parent = await Meme.findById(root)
          .select('variant_of lineage.root')
          .lean()

        if (!parent) break

        // Â¶ÇÊûúÁà∂ÁØÄÈªûÂ∑≤Êúâ lineage.rootÔºåÁõ¥Êé•‰ΩøÁî®
        if (parent.lineage?.root) {
          root = parent.lineage.root
          depth = (parent.lineage.depth || 0) + 1
          break
        }

        // Âê¶ÂâáÁπºÁ∫åÂêë‰∏äËøΩÊ∫Ø
        if (parent.variant_of) {
          root = parent.variant_of
          depth++
        } else {
          // parent Â∞±ÊòØÊ†πÊ∫ê
          root = parent._id
          break
        }
      }

      bulkOps.push({
        updateOne: {
          filter: { _id: meme._id },
          update: {
            $set: {
              lineage: {
                root: root || meme.variant_of,
                depth: depth,
              },
            },
          },
        },
      })

      // ÊØè 500 Á≠ÜÂü∑Ë°å‰∏ÄÊ¨°ÊâπÊ¨°Êõ¥Êñ∞
      if (bulkOps.length >= 500) {
        await Meme.bulkWrite(bulkOps, { ordered: false })
        tracker.update(bulkOps.length)
        bulkOps.length = 0
      }
    }

    // ËôïÁêÜÂâ©È§òÁöÑÊõ¥Êñ∞
    if (bulkOps.length > 0) {
      await Meme.bulkWrite(bulkOps, { ordered: false })
      tracker.update(bulkOps.length)
    }

    tracker.complete()
  } catch (error) {
    console.error('‚ùå Ë®àÁÆóÁ≥ªË≠úÂ§±Êïó:', error)
    throw error
  }
}

// Ê≠•È©ü 3ÔºöÊõ¥Êñ∞‰æÜÊ∫êÁöÑÁµ±Ë®àÊï∏Êìö
const updateSourceStats = async () => {
  console.log('\nüìä Ê≠•È©ü 3ÔºöÊõ¥Êñ∞‰æÜÊ∫êÁöÑÁµ±Ë®àÊï∏Êìö...')
  
  try {
    const sources = await Source.find({ status: { $ne: 'deleted' } }).select('_id')
    
    if (sources.length === 0) {
      console.log('‚ö†Ô∏è  Ê≤íÊúâ‰æÜÊ∫êË≥áÊñôÔºåË∑≥ÈÅéÊ≠§Ê≠•È©ü')
      return
    }

    const tracker = new ProgressTracker(sources.length, 'Êõ¥Êñ∞‰æÜÊ∫êÁµ±Ë®à')

    for (const source of sources) {
      // Ë®àÁÆóÁõ∏ÈóúÁâáÊÆµÊï∏
      const sceneCount = await Scene.countDocuments({
        source_id: source._id,
        status: { $ne: 'deleted' },
      })

      // Ë®àÁÆóÁõ∏ÈóúËø∑Âõ†Êï∏ÂíåÁµ±Ë®à
      const memeStats = await Meme.aggregate([
        {
          $match: {
            source_id: source._id,
            status: { $ne: 'deleted' },
          },
        },
        {
          $group: {
            _id: null,
            count: { $sum: 1 },
            totalViews: { $sum: '$views' },
            totalLikes: { $sum: '$like_count' },
            totalComments: { $sum: '$comment_count' },
          },
        },
      ])

      const stats = memeStats[0] || {
        count: 0,
        totalViews: 0,
        totalLikes: 0,
        totalComments: 0,
      }

      await Source.findByIdAndUpdate(source._id, {
        $set: {
          'counts.scenes': sceneCount,
          'counts.memes': stats.count,
          'counts.views': stats.totalViews,
          'counts.likes': stats.totalLikes,
          'counts.comments': stats.totalComments,
        },
      })

      tracker.update()
    }

    tracker.complete()
  } catch (error) {
    console.error('‚ùå Êõ¥Êñ∞‰æÜÊ∫êÁµ±Ë®àÂ§±Êïó:', error)
    throw error
  }
}

// Ê≠•È©ü 4ÔºöÊõ¥Êñ∞ÁâáÊÆµÁöÑÁµ±Ë®àÊï∏Êìö
const updateSceneStats = async () => {
  console.log('\nüìä Ê≠•È©ü 4ÔºöÊõ¥Êñ∞ÁâáÊÆµÁöÑÁµ±Ë®àÊï∏Êìö...')
  
  try {
    const scenes = await Scene.find({ status: { $ne: 'deleted' } }).select('_id')
    
    if (scenes.length === 0) {
      console.log('‚ö†Ô∏è  Ê≤íÊúâÁâáÊÆµË≥áÊñôÔºåË∑≥ÈÅéÊ≠§Ê≠•È©ü')
      return
    }

    const tracker = new ProgressTracker(scenes.length, 'Êõ¥Êñ∞ÁâáÊÆµÁµ±Ë®à')

    for (const scene of scenes) {
      // Ë®àÁÆó‰ΩøÁî®Ê≠§ÁâáÊÆµÁöÑËø∑Âõ†Êï∏ÂíåÁµ±Ë®à
      const memeStats = await Meme.aggregate([
        {
          $match: {
            scene_id: scene._id,
            status: { $ne: 'deleted' },
          },
        },
        {
          $group: {
            _id: null,
            count: { $sum: 1 },
            totalViews: { $sum: '$views' },
          },
        },
      ])

      const stats = memeStats[0] || {
        count: 0,
        totalViews: 0,
      }

      await Scene.findByIdAndUpdate(scene._id, {
        $set: {
          'counts.memes': stats.count,
          'counts.views': stats.totalViews,
          'counts.uses': stats.count,
        },
      })

      tracker.update()
    }

    tracker.complete()
  } catch (error) {
    console.error('‚ùå Êõ¥Êñ∞ÁâáÊÆµÁµ±Ë®àÂ§±Êïó:', error)
    throw error
  }
}

// Ê≠•È©ü 5ÔºöÂª∫Á´ãÁ¥¢Âºï
const createIndexes = async () => {
  console.log('\nüîç Ê≠•È©ü 5ÔºöÂª∫Á´ãÁ¥¢Âºï...')
  
  try {
    // Meme Á¥¢Âºï
    console.log('  Âª∫Á´ã Meme Á¥¢Âºï...')
    await Meme.collection.createIndex({ source_id: 1 })
    await Meme.collection.createIndex({ scene_id: 1 })
    await Meme.collection.createIndex({ variant_of: 1 })
    await Meme.collection.createIndex({ 'lineage.root': 1 })
    await Meme.collection.createIndex({ 'lineage.root': 1, 'lineage.depth': 1 })
    await Meme.collection.createIndex({ source_id: 1, status: 1 })
    await Meme.collection.createIndex({ scene_id: 1, status: 1 })

    // Source Á¥¢Âºï
    console.log('  Âª∫Á´ã Source Á¥¢Âºï...')
    await Source.collection.createIndex({ slug: 1 }, { unique: true, sparse: true })
    await Source.collection.createIndex({ title: 1 })
    await Source.collection.createIndex({ type: 1, status: 1 })
    await Source.collection.createIndex({ 'counts.memes': -1 })

    // Scene Á¥¢Âºï
    console.log('  Âª∫Á´ã Scene Á¥¢Âºï...')
    await Scene.collection.createIndex({ source_id: 1, start_time: 1 })
    await Scene.collection.createIndex({ source_id: 1, status: 1 })
    await Scene.collection.createIndex({ slug: 1 }, { sparse: true })
    await Scene.collection.createIndex({ 'counts.memes': -1 })

    console.log('‚úÖ Á¥¢ÂºïÂª∫Á´ãÂÆåÊàê')
  } catch (error) {
    console.error('‚ùå Âª∫Á´ãÁ¥¢ÂºïÂ§±Êïó:', error)
    throw error
  }
}

// ‰∏ªÂü∑Ë°åÂáΩÊï∏
const main = async () => {
  console.log('üöÄ ÈñãÂßãÂü∑Ë°å‰∏âÂ±§Ê®°ÂûãË≥áÊñôÈÅ∑Áßª...')
  console.log('================================')
  
  try {
    // ÈÄ£Êé•Ë≥áÊñôÂ∫´
    await connectDB()

    // Âü∑Ë°åÈÅ∑ÁßªÊ≠•È©ü
    await addNewFieldsToMemes()
    await calculateLineage()
    await updateSourceStats()
    await updateSceneStats()
    await createIndexes()

    console.log('\n================================')
    console.log('‚úÖ Ë≥áÊñôÈÅ∑ÁßªÂÆåÊàêÔºÅ')
    console.log('\nüìå ÂæåÁ∫åÊ≠•È©üÔºö')
    console.log('1. ÊâãÂãïÂª∫Á´ã‰æÜÊ∫êÔºàSourceÔºâË≥áÊñô')
    console.log('2. ÊâãÂãïÂª∫Á´ãÁâáÊÆµÔºàSceneÔºâË≥áÊñô')
    console.log('3. ÈÄêÊ≠•ÁÇ∫ÁÜ±ÈñÄËø∑Âõ†ÈóúËÅØ source_id Âíå scene_id')
    console.log('4. ÁÇ∫ËÆäÈ´îËø∑Âõ†Ë®≠ÂÆö variant_of Èóú‰øÇ')
    
  } catch (error) {
    console.error('\n‚ùå ÈÅ∑ÁßªÂ§±Êïó:', error)
    process.exit(1)
  } finally {
    // ÈóúÈñâË≥áÊñôÂ∫´ÈÄ£Êé•
    await mongoose.connection.close()
    console.log('\nüì§ Ë≥áÊñôÂ∫´ÈÄ£Êé•Â∑≤ÈóúÈñâ')
    process.exit(0)
  }
}

// Âü∑Ë°å‰∏ªÂáΩÊï∏
main().catch(console.error)